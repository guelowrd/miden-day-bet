#! ADV_PUSH_MAPVALN: Pushes a list of field elements onto the advice stack.
#! The list is looked up in the advice map using `key` as the key.
#!
#! Stack Input:  [key3, key2, key1, key0, ...]
#! Stack Output: [num_elements, ...] (returns the number of elements pushed)
#!
#! The key is a Word (4 field elements) used to lookup values in the advice map
export.adv_push_mapvaln
    # Stack: [key3, key2, key1, key0, ...]

    # Call the VM instruction to push values from advice map
    adv.push_mapvaln
    # Stack: [key3, key2, key1, key0, ...]
    # Side effect: [n, ele1, ele2, ...] pushed to advice stack where n is the count

    # Drop the key word from the stack
    dropw
    # Stack: [...]

    # The adv.push_mapvaln instruction pushes the count on top of the advice stack
    # We need to pop it from the advice stack to return it
    # Note: The advice stack now has [ele1, ele2, ...] with count removed
    adv_push.1
    # Stack: [num_elements, ...]
end

#! Emits an event to request a Falcon signature loaded to the advice stack
#! MSG and PK are expected to be on the operand stack.
#! Emits the canonical `miden::auth::request` event introduced in node/client 0.12.
#!
#! Inputs:  [msg3, msg2, msg1, msg0, pk3, pk2, pk1, pk0, ...]
#! Outputs: [...]
const.AUTH_REQUEST_EVENT=event("miden::auth::request")
export.emit_falcon_sig_to_stack
    emit.AUTH_REQUEST_EVENT
    dropw dropw
end

#! Insert words loaded from a memory range into the advice map under the given key
#!
#! Inputs:  [key3, key2, key1, key0, start_addr, end_addr, ...]
#! Outputs: [...]
#! Side effects: advice_map[key] <- mem[start_addr..end_addr]
export.adv_insert_mem
    # VM op expects [KEY, a, b, ...] and leaves them on the stack
    adv.insert_mem
    # Drop a,b and the key word from the stack so the proc has no outputs
    drop drop
    dropw
end
